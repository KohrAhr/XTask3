using System;

namespace Factory
{
    // Один из основных плюсов использования шаблона "Фабричный метод" заключается в обеспечении гибкости, расширяемости и управляемости создания объектов в приложении.
    // Вот некоторые из его преимуществ:
    //
    // Изоляция процесса создания: Шаблон "Фабричный метод" инкапсулирует процесс создания объектов в отдельных фабриках.
    // Это позволяет изолировать логику создания объектов от клиентского кода, делая код более поддерживаемым и уменьшая зависимость клиента от конкретных классов.
    //
    // Расширяемость: Вы можете легко добавить новые типы продуктов и их создателей, не изменяя существующий клиентский код.
    // Это обеспечивает открытость/закрытость (Open/Closed Principle) из принципов SOLID.
    //
    // Выбор конкретных реализаций: Паттерн позволяет клиентскому коду выбирать, какой конкретный продукт создавать, в зависимости от текущих потребностей или условий, что дает большую гибкость.
    // Улучшенная тестируемость: Компоненты приложения, использующие фабрику и созданные продукты, могут быть легко тестированы отдельно от процесса создания.
    //
    // Упрощение кода клиента: Клиентский код обычно становится проще и более читаемым, поскольку он взаимодействует с абстракциями(фабриками и продуктами) вместо конкретных реализаций.
    //
    // Соблюдение принципов SOLID: Использование шаблона "Фабричный метод" способствует соблюдению принципов SOLID, таких как Single Responsibility Principle и Open/Closed Principle.
    //
    // Шаблон "Фабричный метод" особенно полезен, когда ваше приложение разрабатывается с учетом будущего расширения и поддержки разных вариантов объектов.
    // Он помогает сделать ваш код более абстрактным и готовым к изменениям, что особенно важно в долгосрочной перспективе разработки приложения.

    // Для простой реализации шаблона "Фабричный метод" достаточно одного абстрактного класса, который представляет собой абстрактную фабрику(или создатель) и имеет абстрактный метод ResolveLatestShippingStatus().
    // В этом случае, каждый конкретный создатель(фабрика) может наследоваться от этого одного абстрактного класса и предоставлять свою реализацию метода ResolveLatestShippingStatus() для создания конкретных продуктов.
    //
    // Пример, предоставленный в предыдущем ответе, иллюстрирует такой подход, где FactoryResolveLatestShippingStatus является абстрактным классом с методом ResolveLatestShippingStatus(), и у него есть две конкретные реализации: FactoryFedEx и FactoryUPS.
    // Каждая из этих конкретных фабрик создает свой собственный конкретный продукт.
    //
    // Однако в некоторых более сложных сценариях, может потребоваться иметь дополнительные абстрактные классы, связанные с продуктами или другими аспектами системы.
    // В зависимости от конкретных требований и структуры приложения, вы можете создать более сложную иерархию классов, чтобы сделать вашу систему более гибкой и модульной.

    /// <summary>
    ///     Design Pattern -- Factory -- minimal demo
    /// </summary>
    internal class Program
    {
        static void Main(string[] args)
        {
            FactoryResolveLatestShippingStatus factoryResolveLatestShippingStatusForUps = new FactoryUps();
            FactoryResolveLatestShippingStatus factoryResolveLatestShippingStatusForFedEx = new FactoryFedEx();

            Console.WriteLine(factoryResolveLatestShippingStatusForUps.ResolveLatestShippingStatus("1Z....."));
            Console.WriteLine(factoryResolveLatestShippingStatusForFedEx.ResolveLatestShippingStatus("1111111"));

            Console.ReadKey();
        }
    }
}
